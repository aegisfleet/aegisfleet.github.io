<!DOCTYPE html>
<html lang="ja" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=448, user-scalable=no">
    <title>Triple Triad</title>
    <link rel="icon" href="favicon.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            touch-action: manipulation;
            background-color: #111827;
            background-image: linear-gradient(to bottom, #111827, #1e3a8a);
            color: white;
            width: 100vw;
            height: 100vh;
            overflow: hidden; 
        }

        @keyframes flipEffect {
            0% { transform: scale(1.0) rotateY(0deg); opacity: 1; }
            50% { transform: scale(0.9) rotateY(90deg); opacity: 0.7; }
            100% { transform: scale(1.0) rotateY(0deg); opacity: 1; }
        }
        .is-flipping {
            animation: flipEffect 0.5s ease-out;
            animation-fill-mode: forwards;
        }

        .card-flip {
            transition: background-color 0.4s ease, border-color 0.4s ease, transform 0.3s ease, box-shadow 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .card-num {
            position: absolute;
            width: 1.25rem;
            height: 1.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            font-size: 0.875rem;
            border-radius: 0.25rem;
            background-color: rgba(0, 0, 0, 0.4);
            color: white;
            line-height: 1;
        }
        .card-num-a { color: #FACC15; }
        .card-num-top { top: 2px; left: 50%; transform: translateX(-50%); }
        .card-num-bottom { bottom: 2px; left: 50%; transform: translateX(-50%); }
        .card-num-left { left: 2px; top: 50%; transform: translateY(-50%); }
        .card-num-right { right: 2px; top: 50%; transform: translateY(-50%); }

        .card-name {
            font-size: 0.6rem;
            font-weight: 700;
            opacity: 0.8;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            letter-spacing: -0.05em;
            color: white;  
        }

        .selected-card {
            transform: scale(1.1) translateY(-10px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            border-color: #FACC15;
            z-index: 10;
        }
        
        .cpu-thinking-card {
            transform: scale(1.1) translateY(10px);
            box-shadow: 0 -10px 20px rgba(0,0,0,0.3);
            border-color: #F87171;
            z-index: 10;
        }

        .turn-indicator {
            transition: all 0.3s ease;
        }

        @keyframes scoreUpdate {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); background-color: #374151; }
            100% { transform: scale(1); }
        }
        .score-updating {
            animation: scoreUpdate 0.4s ease-out;
        }

        @keyframes winnerCard {
            0% { transform: scale(1); box-shadow: 0 0 10px rgba(0,0,0,0.5); }
            50% { transform: scale(1.1); box-shadow: 0 0 20px 10px rgba(255, 255, 150, 0.7); }
            100% { transform: scale(1); box-shadow: 0 0 10px rgba(0,0,0,0.5); }
        }
        .winner-card {
            animation: winnerCard 0.5s ease-in-out 0.2s;
            z-index: 5;
        }

        .cell {
            background-color: rgba(0, 0, 0, 0.3);
            border-color: rgba(255, 255, 255, 0.2);
        }
        .cell-empty-hover:hover {
            background-color: rgba(0, 0, 0, 0.5);
        }

        .hidden {
            display: none;
        }

        #game-wrapper {
            width: 448px; 
            position: relative;
        }

        .rule-notice {
            position: fixed;
            top: 15%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.85);
            color: #FACC15;
            font-size: 1.5rem;
            font-weight: bold;
            padding: 1rem 2rem;
            border-radius: 0.5rem;
            border: 2px solid #FACC15;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s ease, top 0.3s ease;
            pointer-events: none;
            text-shadow: 0 1px 3px rgba(0,0,0,0.7);
        }
        .rule-notice.show {
            opacity: 1;
            top: 10%;
        }

        .cell-hint {
            background-color: rgba(250, 204, 21, 0.4) !important;
            box-shadow: 0 0 10px #FACC15;
        }

    </style>
</head>

<body class="flex items-center justify-center">

    <div id="game-wrapper" class="flex flex-col justify-between p-4">

        <div id="start-overlay" class="absolute inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 cursor-pointer">
            <h2 class="text-3xl font-bold text-yellow-400 animate-pulse">クリックして開始</h2>
        </div>

        <div id="player-2-area" class="w-full">
            <div id="turn-p2" class="turn-indicator text-center p-2 mb-2 rounded-lg bg-gray-800 border-2 border-transparent">
                <h2 class="font-bold text-red-400">CPU</h2>
                <p>スコア: <span id="score-p2" class="font-bold text-xl">0</span></p>
            </div>
            <div id="hand-p2" class="flex justify-center h-24 space-x-1">
            </div>
        </div>

        <div id="game-board" class="w-full max-w-xs mx-auto grid grid-cols-3 gap-1 aspect-square my-4">
        </div>

        <div id="player-1-area" class="w-full">
            <div id="hand-p1" class="flex justify-center h-24 space-x-1 mb-2">
            </div>
            <div id="turn-p1" class="turn-indicator text-center p-2 mt-2 rounded-lg bg-gray-800 border-2 border-transparent">
                <h2 class="font-bold text-blue-400">あなた</h2>
                <p>スコア: <span id="score-p1" class="font-bold text-xl">0</span></p>
            </div>
        </div>
    </div>

    <div id="result-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50">
        <div class="bg-gray-800 p-8 rounded-lg shadow-xl text-center">
            <h2 id="result-message" class="text-3xl font-bold mb-6"></h2>
            <p class="text-lg mb-6">最終スコア</p>
            <div class="flex justify-around mb-8">
                <div class="text-blue-400">
                    <span class="text-sm">あなた</span>
                    <p id="result-score-p1" class="text-4xl font-bold">0</p>
                </div>
                <div class="text-red-400">
                    <span class="text-sm">CPU</span>
                    <p id="result-score-p2" class="text-4xl font-bold">0</p>
                </div>
            </div>
            <button id="restart-button" class="w-full bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-bold py-3 px-6 rounded-lg text-xl transition-all duration-200 hover:scale-105 transform">
                もう一度遊ぶ
            </button>
        </div>
    </div>

    <div id="turn-notice" class="hidden fixed inset-0 flex items-center justify-center bg-black bg-opacity-70 z-40 p-4">
        <div class="bg-gray-700 p-6 rounded-lg shadow-xl text-center">
            <p id="turn-notice-message" class="text-2xl font-bold"></p>
        </div>
    </div>

    <div id="rule-notice" class="rule-notice"></div>

    <script>
        const allCards = [
            { id: 1, name: 'イフリート', stats: { top: 6, right: 9, bottom: 4, left: 8 } },
            { id: 2, name: 'トンベリ', stats: { top: 4, right: 8, bottom: 9, left: 4 } },
            { id: 3, name: 'シヴァ', stats: { top: 2, right: 6, bottom: 9, left: 7 } },
            { id: 4, name: 'セイレーン', stats: { top: 5, right: 1, bottom: 6, left: 4 } },
            { id: 5, name: 'ミノタウロス', stats: { top: 9, right: 5, bottom: 2, left: 8 } },
            { id: 6, name: 'カーバンクル', stats: { top: 8, right: 4, bottom: 4, left: 6 } },
            { id: 7, name: 'ケツァクウァトル', stats: { top: 7, right: 4, bottom: 8, left: 1 } },
            { id: 8, name: 'サボテンダー', stats: { top: 10, right: 3, bottom: 3, left: 3 } },
            { id: 9, name: 'グラシャラボラス', stats: { top: 5, right: 8, bottom: 3, left: 5 } },
            { id: 10, name: 'コモーグリ', stats: { top: 1, right: 3, bottom: 1, left: 7 } },
            { id: 11, name: 'ディアブロス', stats: { top: 5, right: 10, bottom: 8, left: 3 } },
            { id: 12, name: 'バハムート', stats: { top: 10, right: 8, bottom: 6, left: 8 } },
            { id: 13, name: 'オーディン', stats: { top: 10, right: 4, bottom: 8, left: 8 } },
            { id: 14, name: 'ギルガメッシュ', stats: { top: 3, right: 7, bottom: 10, left: 6 } },
            { id: 15, name: 'キスティス', stats: { top: 9, right: 6, bottom: 2, left: 7 } },
            { id: 16, name: 'コチョコボ', stats: { top: 2, right: 1, bottom: 4, left: 2 } },
        ];

        let player1Hand = [];
        let player2Hand = [];
        let board = Array(9).fill(null); 
        let currentPlayer = 1;
        let selectedCard = null; 
        let scores = { player1: 0, player2: 0 };
        let isPlayerTurn = true; 
        let isGameOver = false;

        const boardElement = document.getElementById('game-board');
        const handP1Element = document.getElementById('hand-p1');
        const handP2Element = document.getElementById('hand-p2');
        const scoreP1Element = document.getElementById('score-p1');
        const scoreP2Element = document.getElementById('score-p2');
        const turnP1Element = document.getElementById('turn-p1');
        const turnP2Element = document.getElementById('turn-p2');
        const modalElement = document.getElementById('result-modal');
        const resultMessageElement = document.getElementById('result-message');
        const resultScoreP1Element = document.getElementById('result-score-p1');
        const resultScoreP2Element = document.getElementById('result-score-p2');
        const restartButton = document.getElementById('restart-button');
        const turnNoticeElement = document.getElementById('turn-notice');
        const turnNoticeMessageElement = document.getElementById('turn-notice-message');
        const ruleNoticeElement = document.getElementById('rule-notice');
        const gameWrapper = document.getElementById('game-wrapper');
        const startOverlay = document.getElementById('start-overlay');

        function showRuleNotice(message) {
            if (!ruleNoticeElement) return;
            ruleNoticeElement.textContent = message;
            ruleNoticeElement.classList.add('show');
            
            setTimeout(() => {
                ruleNoticeElement.classList.remove('show');
            }, 1500);
        }
        
        let isAudioReady = false;
        let sfxPlace, sfxFlip, sfxWin, sfxLose;

        async function checkAndInitAudio() {
            if (isAudioReady) return;
            try {
                await Tone.start();
                console.log('Audio Context started');
                isAudioReady = true;
            } catch (e) {
                console.error("Tone.start failed", e);
            }
        }

        function setupAudio() {
            sfxPlace = new Tone.MembraneSynth({
                pitchDecay: 0.01,
                octaves: 2,
                envelope: { attack: 0.005, decay: 0.1, sustain: 0 }
            }).toDestination();
            
            sfxFlip = new Tone.Synth({
                oscillator: { type: 'triangle' },
                envelope: { attack: 0.01, decay: 0.1, release: 0.1 }
            }).toDestination();
            
            sfxWin = new Tone.Synth().toDestination();
            sfxLose = new Tone.Synth().toDestination();
        }

        function playPlaceSfx() {
            if (!isAudioReady) return;
            sfxPlace.triggerAttackRelease("C2", "8n", Tone.now());
        }

        function playFlipSfx() {
            if (!isAudioReady) return;
            sfxFlip.triggerAttackRelease("G4", "16n", Tone.now());
            sfxFlip.frequency.setValueAtTime("G4", Tone.now());
            sfxFlip.frequency.linearRampToValueAtTime("C5", Tone.now() + 0.1);
        }

        function playWinSfx() {
            if (!isAudioReady) return;
            const now = Tone.now();
            sfxWin.triggerAttackRelease("C4", "8n", now);
            sfxWin.triggerAttackRelease("E4", "8n", now + 0.1);
            sfxWin.triggerAttackRelease("G4", "8n", now + 0.2);
            sfxWin.triggerAttackRelease("C5", "4n", now + 0.3);
        }

        function playLoseSfx() {
            if (!isAudioReady) return;
            const now = Tone.now();
            sfxLose.triggerAttackRelease("C5", "8n", now);
            sfxLose.triggerAttackRelease("G4", "8n", now + 0.1);
            sfxLose.triggerAttackRelease("E4", "8n", now + 0.2);
            sfxLose.triggerAttackRelease("C4", "4n", now + 0.3);
        }

        function displayValue(value) {
            return value === 10 ? 'A' : String(value);
        }
        function getNumClass(value) {
            return value === 10 ? 'card-num-a' : '';
        }

        function shuffle(array) {
            let currentIndex = array.length, randomIndex;
            while (currentIndex !== 0) {
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;
                [array[currentIndex], array[randomIndex]] = [
                    array[randomIndex], array[currentIndex]];
            }
            return array;
        }

        function createCardElement(card, isP1Hand = false) {
            const cardEl = document.createElement('div');
            cardEl.className = 'card-flip w-1/5 aspect-[3/4] rounded-lg border-2 flex-shrink-0 shadow-lg';
            
            const isP1 = card.owner === 1;
            const gradient = isP1
                ? 'bg-gradient-to-br from-blue-600 to-blue-800'
                : 'bg-gradient-to-br from-red-600 to-red-800';
            const borderColor = isP1
                ? 'border-blue-400'
                : 'border-red-400';
            
            gradient.split(' ').forEach(cls => cardEl.classList.add(cls));
            cardEl.classList.add(borderColor);

            if (isP1Hand) {
                cardEl.classList.add('cursor-pointer');
            }

            const stats = card.stats;
            cardEl.innerHTML = `
                <span class="card-num card-num-top ${getNumClass(stats.top)}">${displayValue(stats.top)}</span>
                <span class="card-num card-num-bottom ${getNumClass(stats.bottom)}">${displayValue(stats.bottom)}</span>
                <span class="card-num card-num-left ${getNumClass(stats.left)}">${displayValue(stats.left)}</span>
                <span class="card-num card-num-right ${getNumClass(stats.right)}">${displayValue(stats.right)}</span>
                <span class="card-name absolute top-1/2 left-1/2 -translate-y-1/2 -translate-x-1/2">${card.name}</span>
            `;
            return cardEl;
        }

        function renderBoard() {
            boardElement.innerHTML = '';
            board.forEach((card, index) => {
                const cell = document.createElement('div');
                cell.className = 'cell border-2 rounded-lg flex items-center justify-center p-0.5 transition-all';
                
                if (card) {
                    const cardEl = createCardElement(card, false);
                    cardEl.classList.remove('w-1/5', 'aspect-[3/4]');
                    cardEl.classList.add('w-full', 'h-full');
                    cell.appendChild(cardEl);
                } else {
                    cell.dataset.index = index;
                    if (isPlayerTurn) {
                        cell.classList.add('cursor-pointer', 'cell-empty-hover');
                    }
                }
                boardElement.appendChild(cell);
            });
        }

        function renderHands() {
            handP1Element.innerHTML = '';
            player1Hand.forEach((card, index) => {
                const cardEl = createCardElement(card, true);
                cardEl.dataset.index = index;
                cardEl.dataset.player = 1;
                if (selectedCard && selectedCard.player === 1 && selectedCard.handIndex === index) {
                    cardEl.classList.add('selected-card');
                }
                handP1Element.appendChild(cardEl);
            });

            handP2Element.innerHTML = '';
            player2Hand.forEach((card, index) => {
                const cardEl = createCardElement(card, false);
                cardEl.dataset.index = index;
                cardEl.dataset.player = 2;
                handP2Element.appendChild(cardEl);
            });
        }
        
        function renderStatus() {
            const oldScore1 = parseInt(scoreP1Element.textContent, 10);
            const newScore1 = scores.player1;
            if (newScore1 !== oldScore1) {
                scoreP1Element.textContent = newScore1;
                turnP1Element.classList.add('score-updating');
                setTimeout(() => turnP1Element.classList.remove('score-updating'), 400);
            } else {
                 scoreP1Element.textContent = newScore1;
            }

            const oldScore2 = parseInt(scoreP2Element.textContent, 10);
            const newScore2 = scores.player2;
            if (newScore2 !== oldScore2) {
                scoreP2Element.textContent = newScore2;
                turnP2Element.classList.add('score-updating');
                setTimeout(() => turnP2Element.classList.remove('score-updating'), 400);
            } else {
                scoreP2Element.textContent = newScore2;
            }

            if (isGameOver) {
                turnP1Element.classList.remove('border-yellow-400', 'bg-gray-700');
                turnP2Element.classList.remove('border-yellow-400', 'bg-gray-700');
            } else if (currentPlayer === 1) {
                turnP1Element.classList.add('border-yellow-400', 'bg-gray-700');
                turnP2Element.classList.remove('border-yellow-400', 'bg-gray-700');
            } else {
                turnP2Element.classList.add('border-yellow-400', 'bg-gray-700');
                turnP1Element.classList.remove('border-yellow-400', 'bg-gray-700');
            }
        }

        function renderAll() {
            renderBoard();
            renderHands();
            renderStatus();
        }
        
        function startGame() {
            gameWrapper.classList.remove('hidden');
            isGameOver = false;
            const deck = shuffle([...allCards]);
            player1Hand = deck.slice(0, 5).map(c => ({ ...c, owner: 1 }));
            player2Hand = deck.slice(5, 10).map(c => ({ ...c, owner: 2 }));
            board = Array(9).fill(null);
            
            if (Math.random() < 0.5) {
                currentPlayer = 1;
                isPlayerTurn = true;
            } else {
                currentPlayer = 2;
                isPlayerTurn = false;
            }
            selectedCard = null;
            scores = { player1: 0, player2: 0 };
            
            scoreP1Element.textContent = '0';
            scoreP2Element.textContent = '0';

            modalElement.classList.add('hidden');
            
            setupAudio();
            renderAll(); 

            if (isPlayerTurn) {
                turnNoticeMessageElement.textContent = "あなたが先行です";
            } else {
                turnNoticeMessageElement.textContent = "CPUが先行です";
            }
            turnNoticeElement.classList.remove('hidden');

            setTimeout(() => {
                turnNoticeElement.classList.add('hidden');
                if (!isPlayerTurn) {
                    setTimeout(cpuTurn, 500); 
                }
            }, 2000);
        }

        function checkAndFlip(boardIndex, cardToPlace) {
            const placedPlayer = cardToPlace.owner;
            const adjacentCards = [];

            const adjacentIndices = [
                { idx: boardIndex - 3, side: 'top', opposite: 'bottom' },
                { idx: boardIndex + 3, side: 'bottom', opposite: 'top' },
                { idx: boardIndex - 1, side: 'left', opposite: 'right' },
                { idx: boardIndex + 1, side: 'right', opposite: 'left' }
            ];

            for (const adj of adjacentIndices) {
                const adjIndex = adj.idx;
                if (adjIndex < 0 || adjIndex > 8) continue;
                if (adj.side === 'left' && boardIndex % 3 === 0) continue;
                if (adj.side === 'right' && boardIndex % 3 === 2) continue;

                const adjacentCard = board[adjIndex];
                if (adjacentCard && adjacentCard.owner !== placedPlayer) {
                    adjacentCards.push({
                        index: adj.idx,
                        card: adjacentCard,
                        side: adj.side,
                        opposite: adj.opposite
                    });
                }
            }

            if (adjacentCards.length === 0) {
                return { type: 'none', indices: [] };
            }

            const comparisons = adjacentCards.map(adj => {
                const placedValue = cardToPlace.stats[adj.side];
                const adjacentValue = adj.card.stats[adj.opposite];
                return {
                    index: adj.index,
                    sameValue: placedValue === adjacentValue ? placedValue : null,
                    plusValue: placedValue + adjacentValue
                };
            });

            // ★修正: セイム判定
            const sameMatches = comparisons.filter(c => c.sameValue !== null);
            if (sameMatches.length >= 2) {
                const flippedIndices = sameMatches.map(c => c.index);
                return { type: 'same', indices: [...new Set(flippedIndices)] };
            }

            // プラス判定
            const plusCounts = {};
            comparisons.forEach(c => {
                plusCounts[c.plusValue] = (plusCounts[c.plusValue] || 0) + 1;
            });
            const plusTriggeredValue = Object.keys(plusCounts).find(value => plusCounts[value] >= 2);

            if (plusTriggeredValue) {
                const flippedIndices = comparisons
                    .filter(c => c.plusValue == plusTriggeredValue)
                    .map(c => c.index);
                return { type: 'plus', indices: [...new Set(flippedIndices)] };
            }

            // 基本ルール
            const basicFlips = adjacentCards.filter(adj => {
                const placedValue = cardToPlace.stats[adj.side];
                const adjacentValue = adj.card.stats[adj.opposite];
                return placedValue > adjacentValue;
            }).map(adj => adj.index);

            return { type: 'basic', indices: basicFlips };
        }

        function updateScores() {
            scores.player1 = board.filter(c => c && c.owner === 1).length;
            scores.player2 = board.filter(c => c && c.owner === 2).length;
        }

        function checkGameOver() {
            if (board.every(cell => cell !== null)) {
                isGameOver = true;
                isPlayerTurn = false;
                renderStatus(); 

                let message = "";
                let winner = 0;
                if (scores.player1 > scores.player2) {
                    message = "あなたの勝利！";
                    playWinSfx();
                    winner = 1;
                } else if (scores.player2 > scores.player1) {
                    message = "CPUの勝利！";
                    playLoseSfx();
                    winner = 2;
                } else {
                    message = "引き分け！";
                    playLoseSfx();
                    winner = 0;
                }
                
                if (winner !== 0) {
                    board.forEach((card, index) => {
                        if (card && card.owner === winner) {
                            const cell = boardElement.children[index];
                            const cardEl = cell.querySelector('.card-flip');
                            if (cardEl) {
                                cardEl.classList.add('winner-card');
                            }
                        }
                    });
                }
                
                setTimeout(() => {
                    resultMessageElement.textContent = message;
                    resultScoreP1Element.textContent = scores.player1;
                    resultScoreP2Element.textContent = scores.player2;
                    modalElement.classList.remove('hidden');
                    gameWrapper.classList.add('hidden');
                }, 1000); 
            }
        }

        function switchPlayer() {
            currentPlayer = currentPlayer === 1 ? 2 : 1;
            isPlayerTurn = (currentPlayer === 1);
            renderStatus();

            if (!isPlayerTurn) {
                setTimeout(cpuTurn, 1000);
            }
        }
        
        async function playTurn(boardIndex, cardToPlace) {
            const placedPlayer = cardToPlace.owner;
            
            board[boardIndex] = cardToPlace;
            
            renderAll();
            playPlaceSfx();
            await new Promise(resolve => setTimeout(resolve, 50)); 
            
            const initialFlipResult = checkAndFlip(boardIndex, cardToPlace);
            
            if (initialFlipResult.type === 'same') {
                showRuleNotice("セイム！");
            } else if (initialFlipResult.type === 'plus') {
                showRuleNotice("プラス！");
            }

            const allFlippedIndices = new Set();
            const flipQueue = [];

            if (initialFlipResult.indices.length > 0) {
                playFlipSfx();
                
                for (const index of initialFlipResult.indices) {
                    if (!allFlippedIndices.has(index)) {
                        const card = board[index];
                        card.owner = placedPlayer;
                        allFlippedIndices.add(index);
                        
                        if (initialFlipResult.type === 'same' || initialFlipResult.type === 'plus') {
                            flipQueue.push(index);
                        }
                        
                        const cell = boardElement.children[index];
                        const cardEl = cell.querySelector('.card-flip');
                        if (cardEl) cardEl.classList.add('is-flipping');
                    }
                }
            }
            
            while (flipQueue.length > 0) {
                const currentIndex = flipQueue.shift();
                const currentCard = board[currentIndex];
                
                const adjacentIndices = [
                    { idx: currentIndex - 3, side: 'top', opposite: 'bottom' },
                    { idx: currentIndex + 3, side: 'bottom', opposite: 'top' },
                    { idx: currentIndex - 1, side: 'left', opposite: 'right' },
                    { idx: currentIndex + 1, side: 'right', opposite: 'left' }
                ];

                for (const adj of adjacentIndices) {
                    const adjIndex = adj.idx;
                    
                    if (adjIndex < 0 || adjIndex > 8) continue;
                    if (adj.side === 'left' && currentIndex % 3 === 0) continue;
                    if (adj.side === 'right' && currentIndex % 3 === 2) continue;
                    
                    const adjacentCard = board[adjIndex];
                    
                    if (adjacentCard && adjacentCard.owner !== placedPlayer && !allFlippedIndices.has(adjIndex)) {
                        
                        const placedValue = currentCard.stats[adj.side];
                        const adjacentValue = adjacentCard.stats[adj.opposite];

                        if (placedValue > adjacentValue) {
                            adjacentCard.owner = placedPlayer;
                            allFlippedIndices.add(adjIndex);
                            flipQueue.push(adjIndex);
                            
                            const cell = boardElement.children[adjIndex];
                            const cardEl = cell.querySelector('.card-flip');
                            if (cardEl) cardEl.classList.add('is-flipping');
                        }
                    }
                }
            }
            
            await new Promise(resolve => setTimeout(resolve, 500));
            updateScores();
            renderAll();
            
            checkGameOver();
            if (!isGameOver) {
                switchPlayer();
            }
        }

        async function cpuTurn() {
            if (isGameOver || player2Hand.length === 0) return;

            await new Promise(resolve => setTimeout(resolve, 300)); 
            let randomHighlight = 0;
            const maxHighlights = player2Hand.length > 1 ? 2 : 1;
            
            for (let i = 0; i < maxHighlights; i++) {
                randomHighlight = Math.floor(Math.random() * player2Hand.length);
                const cardEl = handP2Element.children[randomHighlight];
                if(cardEl) {
                    cardEl.classList.add('cpu-thinking-card');
                    await new Promise(resolve => setTimeout(resolve, 300));
                    cardEl.classList.remove('cpu-thinking-card');
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }

            const availableCells = [];
            board.forEach((cell, index) => {
                if (cell === null) {
                    availableCells.push(index);
                }
            });
            if (availableCells.length === 0) return;

            let bestMove = { cardIndex: -1, boardIndex: -1, flips: -1 };

            for (let i = 0; i < player2Hand.length; i++) {
                const card = player2Hand[i];
                for (const boardIndex of availableCells) {
                    const cardToPlace = { ...card, owner: 2 };
                    let currentFlips = 0;
                    const adjacentIndices = [
                        { idx: boardIndex - 3, side: 'top', opposite: 'bottom' }, 
                        { idx: boardIndex + 3, side: 'bottom', opposite: 'top' },
                        { idx: boardIndex - 1, side: 'left', opposite: 'right' },
                        { idx: boardIndex + 1, side: 'right', opposite: 'left' }
                    ];

                    for (const adj of adjacentIndices) {
                        const adjIndex = adj.idx;
                        if (adjIndex < 0 || adjIndex > 8) continue;
                        if (adj.side === 'left' && boardIndex % 3 === 0) continue;
                        if (adj.side === 'right' && boardIndex % 3 === 2) continue;
                        
                        const adjacentCard = board[adjIndex];
                        if (adjacentCard && adjacentCard.owner === 1) { 
                            if (cardToPlace.stats[adj.side] > adjacentCard.stats[adj.opposite]) {
                                currentFlips++;
                            }
                        }
                    }

                    if (currentFlips > bestMove.flips) {
                        bestMove = { cardIndex: i, boardIndex: boardIndex, flips: currentFlips };
                    }
                }
            }
            
            if (bestMove.flips <= 0) {
                bestMove.cardIndex = Math.floor(Math.random() * player2Hand.length);
                bestMove.boardIndex = availableCells[Math.floor(Math.random() * availableCells.length)];
            }
            
            const cardToPlay = player2Hand.splice(bestMove.cardIndex, 1)[0];
            cardToPlay.owner = 2;
            
            await new Promise(resolve => setTimeout(resolve, 500)); 

            await playTurn(bestMove.boardIndex, cardToPlay);
        }

        function clearHints() {
            boardElement.querySelectorAll('.cell.cell-hint').forEach(cell => {
                cell.classList.remove('cell-hint');
            });
        }

        function renderHints(indices) {
            clearHints();
            indices.forEach(index => {
                const cell = boardElement.children[index];
                if (cell && !board[index]) {
                    cell.classList.add('cell-hint');
                }
            });
        }

        function calculateHints(card) {
            if (!card) return [];
            
            const hintIndices = [];
            const availableCells = [];
            board.forEach((cell, index) => {
                if (cell === null) availableCells.push(index);
            });

            for (const boardIndex of availableCells) {
                const cardToPlace = { ...card, owner: 1 };
                const result = checkAndFlip(boardIndex, cardToPlace);
                
                if (result.type === 'same' || result.type === 'plus') {
                    hintIndices.push(boardIndex);
                }
            }
            return hintIndices;
        }

        async function onHandClick(e) {
            if (!isPlayerTurn || isGameOver || !isAudioReady) return;

            clearHints();

            const cardEl = e.target.closest('[data-player="1"]');
            if (!cardEl) return;

            const handIndex = parseInt(cardEl.dataset.index, 10);
            
            if (selectedCard && selectedCard.handIndex === handIndex) {
                selectedCard = null;
            } else {
                selectedCard = {
                    card: player1Hand[handIndex],
                    handIndex: handIndex,
                    player: 1
                };
                
                const hints = calculateHints(selectedCard.card);
                renderHints(hints);
            }
            renderHands();
        }

        async function onBoardClick(e) {
            if (!isPlayerTurn || isGameOver || !selectedCard || !isAudioReady) return;

            const cell = e.target.closest('[data-index]');
            if (!cell) return;

            const boardIndex = parseInt(cell.dataset.index, 10);
            if (board[boardIndex]) return;

            isPlayerTurn = false; 
            clearHints();

            const cardToPlace = player1Hand.splice(selectedCard.handIndex, 1)[0];
            cardToPlace.owner = 1;
            selectedCard = null;

            await playTurn(boardIndex, cardToPlace);
        }

        async function onRestartClick() {
            modalElement.classList.add('hidden');
            gameWrapper.classList.remove('hidden');
            startGame();
        }

        handP1Element.addEventListener('click', onHandClick);
        boardElement.addEventListener('click', onBoardClick);
        restartButton.addEventListener('click', onRestartClick);

        startOverlay.addEventListener('click', async () => {
            await checkAndInitAudio();
            startOverlay.classList.add('hidden');
            startGame();
        }, { once: true });

    </script>
</body>
</html>